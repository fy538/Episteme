"""
GraphDeltaService â€” records graph mutations with human-readable narratives.

Every document upload, chat edit, or agent analysis that modifies the graph
should produce a GraphDelta through this service. The narrative summarizes
what changed and why it matters for the user's understanding.
"""
import logging
import uuid
from typing import Any, Dict, List, Optional

from django.db import transaction

from apps.events.models import EventType, ActorType
from apps.events.services import EventService

from .models import GraphDelta, DeltaTrigger, Node, Edge

logger = logging.getLogger(__name__)


class GraphDeltaService:
    """
    Service for creating and querying GraphDelta records.

    A delta captures the diff + a human-readable narrative for every
    graph mutation batch.
    """

    @staticmethod
    @transaction.atomic
    def create_delta(
        project_id: uuid.UUID,
        trigger: str,
        *,
        case_id: uuid.UUID = None,
        source_document=None,
        source_message=None,
        nodes_added: Optional[List[Node]] = None,
        nodes_updated: Optional[List[Node]] = None,
        edges_added: Optional[List[Edge]] = None,
        tensions_surfaced: int = 0,
        assumptions_challenged: int = 0,
        narrative: str = '',
    ) -> GraphDelta:
        """
        Create a GraphDelta record summarizing a batch of graph changes.

        Args:
            project_id: Project this delta belongs to
            trigger: What caused this mutation (DeltaTrigger value)
            case_id: Case this delta belongs to (optional, for case-scoped mutations)
            source_document: Document that triggered the change (optional)
            source_message: Chat message that triggered the change (optional)
            nodes_added: List of newly created nodes
            nodes_updated: List of updated nodes
            edges_added: List of newly created edges
            tensions_surfaced: Number of tensions detected
            assumptions_challenged: Number of assumptions challenged
            narrative: Human-readable summary (generated by LLM or template)

        Returns:
            Created GraphDelta
        """
        nodes_added = nodes_added or []
        nodes_updated = nodes_updated or []
        edges_added = edges_added or []

        # Build structured patch
        patch = {
            'nodes_added': [
                {
                    'id': str(n.id),
                    'type': n.node_type,
                    'content': n.content[:200],
                    'status': n.status,
                }
                for n in nodes_added
            ],
            'nodes_updated': [
                {
                    'id': str(n.id),
                    'type': n.node_type,
                    'content': n.content[:200],
                    'status': n.status,
                }
                for n in nodes_updated
            ],
            'edges_added': [
                {
                    'id': str(e.id),
                    'type': e.edge_type,
                    'source': str(e.source_node_id),
                    'target': str(e.target_node_id),
                }
                for e in edges_added
            ],
        }

        # Generate narrative from template if not provided
        if not narrative:
            narrative = GraphDeltaService._generate_template_narrative(
                trigger=trigger,
                nodes_added=nodes_added,
                nodes_updated=nodes_updated,
                edges_added=edges_added,
                tensions_surfaced=tensions_surfaced,
                assumptions_challenged=assumptions_challenged,
                source_document=source_document,
            )

        delta = GraphDelta.objects.create(
            project_id=project_id,
            case_id=case_id,
            trigger=trigger,
            patch=patch,
            narrative=narrative,
            nodes_created=len(nodes_added),
            nodes_updated=len(nodes_updated),
            edges_created=len(edges_added),
            tensions_surfaced=tensions_surfaced,
            assumptions_challenged=assumptions_challenged,
            source_document=source_document,
            source_message=source_message,
        )

        # Emit event
        EventService.append(
            event_type=EventType.GRAPH_DELTA_COMPUTED,
            payload={
                'delta_id': str(delta.id),
                'project_id': str(project_id),
                'trigger': trigger,
                'nodes_created': len(nodes_added),
                'edges_created': len(edges_added),
                'tensions_surfaced': tensions_surfaced,
                'narrative_preview': narrative[:120],
            },
            actor_type=ActorType.SYSTEM,
        )

        # Mark project summary as stale
        from .summary_service import ProjectSummaryService
        try:
            ProjectSummaryService.mark_stale(project_id)
        except Exception:
            logger.warning("Failed to mark summary stale", exc_info=True)

        return delta

    @staticmethod
    def _generate_template_narrative(
        trigger: str,
        nodes_added: List[Node],
        nodes_updated: List[Node],
        edges_added: List[Edge],
        tensions_surfaced: int,
        assumptions_challenged: int,
        source_document=None,
    ) -> str:
        """
        Generate a template-based narrative when LLM narrative is not available.

        This is a fallback; the extraction pipeline will produce LLM-generated
        narratives for document uploads.
        """
        parts = []

        # Source context
        if source_document and trigger == DeltaTrigger.DOCUMENT_UPLOAD:
            parts.append(f'Processing "{source_document.title}"')
        elif trigger == DeltaTrigger.CHAT_EDIT:
            parts.append("From conversation")
        elif trigger == DeltaTrigger.AGENT_ANALYSIS:
            parts.append("Agent analysis")
        elif trigger == DeltaTrigger.USER_EDIT:
            parts.append("Manual edit")

        # Node counts by type
        if nodes_added:
            type_counts: Dict[str, int] = {}
            for n in nodes_added:
                type_counts[n.node_type] = type_counts.get(n.node_type, 0) + 1
            type_parts = [f"{count} {ntype}{'s' if count > 1 else ''}" for ntype, count in type_counts.items()]
            parts.append(f"added {', '.join(type_parts)}")

        if edges_added:
            parts.append(f"created {len(edges_added)} relationship{'s' if len(edges_added) > 1 else ''}")

        if tensions_surfaced:
            parts.append(f"surfaced {tensions_surfaced} tension{'s' if tensions_surfaced > 1 else ''}")

        if assumptions_challenged:
            parts.append(f"challenged {assumptions_challenged} assumption{'s' if assumptions_challenged > 1 else ''}")

        if nodes_updated:
            parts.append(f"updated {len(nodes_updated)} node{'s' if len(nodes_updated) > 1 else ''}")

        if not parts:
            return "Graph updated."

        # Join with proper punctuation
        narrative = parts[0]
        if len(parts) > 1:
            narrative += ": " + ", ".join(parts[1:]) + "."
        else:
            narrative += "."

        return narrative

    @staticmethod
    def get_document_delta(
        project_id: uuid.UUID,
        document_id: uuid.UUID,
    ) -> Optional[GraphDelta]:
        """
        Get the most recent delta for a specific document in a project.
        """
        return (
            GraphDelta.objects
            .filter(
                project_id=project_id,
                source_document_id=document_id,
            )
            .order_by('-created_at')
            .first()
        )

    @staticmethod
    def get_project_deltas(
        project_id: uuid.UUID,
        limit: int = 20,
    ) -> List[GraphDelta]:
        """
        Get recent deltas for a project, newest first.
        """
        return list(
            GraphDelta.objects
            .filter(project_id=project_id)
            .select_related('source_document', 'source_message')
            .order_by('-created_at')[:limit]
        )
